<html>
<head>
    <meta charset="UTF-8">
    <title>RBLX Portfolio</title>
    <style>
        #canvas1, #canvas2 {
            position:absolute;
            zoom: 1;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            image-rendering: pixelated;
        }
        #canvas1 {
            filter: blur(5px) brightness(0.6) sepia(1) saturate(4) hue-rotate(-25deg);
            opacity: 0.8;
        }
        #canvas2 {
            opacity: 0.5;
        }
        .background-dark {
            position: absolute;
            width: calc(100% - 200px);
            height: calc(100% - 200px);
            left:50%;
            top:50%;
            transform: translate(-50%, -50%);
            border-radius: 50px;
        }
        #content-canvas {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
</head>
<body style="overflow:hidden;margin:0;background-color:rgb(149, 99, 82)">
<canvas id="canvas1"></canvas>
<canvas id="canvas2"></canvas>
<canvas id="content-canvas"></canvas>
<div class="background-dark"></div>
<script>
class Shader {
    constructor(gl, shaderType, content) {
        this.gl = gl;
        this.content = content
        this.shader = this.gl.createShader(shaderType);
        this.gl.shaderSource(this.shader, content);
        this.gl.compileShader(this.shader);
        const success = this.gl.getShaderParameter(this.shader, this.gl.COMPILE_STATUS);
        if(!success) {
            const errorLog = this.gl.getShaderInfoLog(this.shader);
            this.gl.deleteShader(this.shader);
            throw new Error("Failed to compile shader: "+errorLog);
        }
    }
    log() {
        this.content.split('\n').forEach((line, index) => {
            console.log(`${index + 1}: ${line}`);
        });
    }
    delete() {
        this.gl.deleteShader(this.shader);
    }
}

class Program {
    constructor(gl, vertexShader, fragmentShader) {
        this.gl = gl;
        this.program = this.gl.createProgram();
        this.gl.attachShader(this.program, vertexShader.shader);
        this.gl.attachShader(this.program, fragmentShader.shader);
        this.gl.linkProgram(this.program);
        const success = this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS);
        if(!success) {
            console.log(this.gl.getProgramInfoLog(this.program));
            this.gl.deleteProgram(this.program);
        }
    }
    setActive() {
        this.gl.useProgram(this.program);
    }
    delete() {
        this.gl.deleteProgram(this.program);
    }
}

class Buffer {
    constructor(gl, location, dimensions, bufferType) {
        this.gl = gl;
        this.location = location;
        this.dimensions = dimensions;
        this.type = bufferType;
        this.buffer = gl.createBuffer();
    }
    setActive() {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
    }
    bufferData(values) {
        this.gl.bufferData(this.gl.ARRAY_BUFFER, values, this.gl.STATIC_DRAW);
    }
    delete() {
        this.gl.deleteBuffer(this.buffer);
    }
}

class VertexArray {
    constructor(gl) {
        this.gl = gl;
        this.vao = this.gl.createVertexArray();
    }
    setActive() {
        this.gl.bindVertexArray(this.vao);
    };
    enableBuffer(buffer) {
        const gl = this.gl;
        buffer.setActive();
        gl.enableVertexAttribArray(buffer.location);
        if(buffer.type == gl.FLOAT) {
            gl.vertexAttribPointer(buffer.location, buffer.dimensions, buffer.type, false, 0, 0);
        } else {
            gl.vertexAttribIPointer(buffer.location, buffer.dimensions, buffer.type, false, 0, 0);
        }
    }
    delete() {
        const gl = this.gl;
        gl.deleteVertexArray(this.vao);
    }
}

class Uniform {
    constructor(gl, program, name, type) {
        this.gl = gl;
        this.name = name;
        this.type = type;
        this.location = gl.getUniformLocation(program.program, name);
    }
    set(...values) {
        const gl = this.gl;
        switch(this.type) {
            case 'int': gl.uniform1i(this.location, values[0]); break;
            case 'float': gl.uniform1f(this.location, values[0]); break;
            case 'vec2': gl.uniform2f(this.location, values[0], values[1]); break;
            case 'vec3': gl.uniform3f(this.location, values[0], values[1], values[2]); break;
            case 'vec4': gl.uniform4f(this.location, values[0], values[1], values[2], values[3]); break;
            case 'ivec2': gl.uniform2i(this.location, values[0], values[1]); break;
            case 'ivec3': gl.uniform3i(this.location, values[0], values[1], values[2]); break;
            case 'ivec4': gl.uniform4i(this.location, values[0], values[1], values[2], values[3]); break;
            case 'mat4': gl.uniformMatrix4fv(this.location, false, values[0].arr); break;
        }
    }
}

class Texture2D {
    constructor(gl, program, binding, name, image) {
        this.gl = gl;
        this.texture = gl.createTexture();
        this.binding = binding;
        this.setActive();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        if(image) {
            this.setTexture(image);
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        this.uniform = new Uniform(gl, program, name, 'int');
        this.uniform.set(binding);
    }
    setImage(image) {
        const gl = this.gl;
        this.setActive();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
    }
    setActive() {
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + this.binding);
    }
    delete() {
        const gl = this.gl;
        gl.deleteTexture(this.texture);
    }
}

class Texture3D {
    constructor(gl, program, binding, name, width, height, depth, data) {
        this.gl = gl;
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.texture = gl.createTexture();
        this.binding = binding;
        this.setActive();
        gl.bindTexture(gl.TEXTURE_3D, this.texture);
        gl.texImage3D(gl.TEXTURE_3D, 0, gl.RGBA, width, height, depth, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        this.uniform = new Uniform(gl, program, name, 'int');
        this.uniform.set(binding);
    }
    setActive() {
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + this.binding);
    }
    update(x0,y0,z0,w,h,d,data) {
        const gl = this.gl;
        this.setActive();
        gl.bindTexture(gl.TEXTURE_3D, this.texture);
        gl.texSubImage3D(gl.TEXTURE_3D, 0, x0, y0, z0, w, h, d, gl.RGBA, gl.UNSIGNED_BYTE, data);
    }
    delete() {
        const gl = this.gl;
        gl.deleteTexture(this.texture);
    }
}
</script>
<script>
class Mat4 {
    // Row-Major 4x4 Matrix
    constructor(...a) {
        this.arr = a ?? [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1,
        ];
    }
    multiply(other) {
        if(other instanceof Mat4) {
            const result = new Mat4();
            for(let x_column=0;x_column<4;x_column++){
                for(let y_row=0;y_row<4;y_row++){
                    let total = 0;
                    for(let i=0;i<4;i++) total+=this.arr[4*y_row + i] * other.arr[x_column + i*4];
                    result.arr[x_column + y_row*4] = total;
                }
            }
            return result;
        }
    }
    static translation(x, y, z) {
        return new Mat4(
            1, 0, 0, x,
            0, 1, 0, y,
            0, 0, 1, z,
            0, 0, 0, 1,
        );
    }
    static scale(x, y, z) {
        return new Mat4(
            x, 0, 0, 0,
            0, y, 0, 0,
            0, 0, z, 0,
            0, 0, 0, 1,
        );
    }
    static rotationX(a=0) {
        const S = Math.sin(a);
        const C = Math.cos(a);
        return new Mat4(
            1, 0, 0, 0,
            0, C,-S, 0,
            0, S, C, 0,
            0, 0, 0, 1,
        );
    }
    static rotationY(a=0) {
        const S = Math.sin(a);
        const C = Math.cos(a);
        return new Mat4(
            C, 0, S, 0,
            0, 1, 0, 0,
           -S, 0, C, 0,
            0, 0, 0, 1,
        );
    }
    static rotationZ(a=0) {
        const S = Math.sin(a);
        const C = Math.cos(a);
        return new Mat4(
            C,-S, 0, 0,
            S, C, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1,
        );
    }
    static rotationZYX(x, y, z) {
        const rx = Mat4.rotationX(x);
        const ry = Mat4.rotationY(y);
        const rz = Mat4.rotationZ(z);
        return rx.multiply(ry.multiply(rz));
    }
    static rotationXYZ(x, y, z) {
        const rx = Mat4.rotationX(x);
        const ry = Mat4.rotationY(y);
        const rz = Mat4.rotationZ(z);
        return rz.multiply(ry.multiply(rx));
    }
    static perspective(fov,aspect,near,far) {
        const f = 1.0 / Math.tan(fov / 2);
        const nf = 1 / (near - far);
        return new Mat4(
            f/aspect, 0, 0, 0,
            0, f, 0, 0,
            0, 0, (far+near)*nf, -1,
            0, 0, (2*far*near)*nf, 0,
        );
    }
}
</script>
<script>
    /////////////////////////////////
    // Particle Network Background //
    /////////////////////////////////
    const nodeCount = 200;
    const extendBounds = 100;
    const connectionDistance = 12;
    const canvasPadding = 100;
    const resolution = 1;
    let mouseX = 0;
    let mouseY = 0;

    const canvas = document.querySelector('#canvas1');
    const ctx = canvas.getContext('2d');
    canvas.style.zoom = resolution;
    const canvas2 = document.querySelector('#canvas2');
    const ctx2 = canvas2.getContext('2d');
    canvas2.style.zoom = resolution;
    function resize() {
        canvas.width = Math.floor((window.innerWidth + canvasPadding)/resolution);
        canvas.height = Math.floor((window.innerHeight + canvasPadding)/resolution);
        canvas2.width = Math.floor((window.innerWidth + canvasPadding)/resolution);
        canvas2.height = Math.floor((window.innerHeight + canvasPadding)/resolution);
    }
    window.addEventListener('resize', resize);
    resize();

    window.addEventListener('mousemove', (event) => {
        mouseX = (event.clientX + canvasPadding / 2) / resolution;
        mouseY = (event.clientY + canvasPadding / 2) / resolution;
    });

    class Node {
        static nodes = [];
        static partitions = {};
        static partitionSize = 100;
        constructor() {
            this.setPosition(
                Math.random() * (canvas.width * resolution + extendBounds * 2) - extendBounds,
                Math.random() * (canvas.height * resolution + extendBounds * 2) - extendBounds
            );
            this.vx = (Math.random() - 0.5) * 0.5;
            this.vy = (Math.random() - 0.5) * 0.5;
            Node.nodes.push(this);
        }
        setPosition(x, y) {
            this.x = x;
            this.y = y;
            if(this.x < -extendBounds) this.x = canvas.width * resolution + extendBounds;
            if(this.x > canvas.width * resolution + extendBounds) this.x = -extendBounds;
            if(this.y < -extendBounds) this.y = canvas.height * resolution + extendBounds;
            if(this.y > canvas.height * resolution + extendBounds) this.y = -extendBounds;
            const lastPx = this.px;
            const lastPy = this.py;
            this.px = Math.floor(x / Node.partitionSize);
            this.py = Math.floor(y / Node.partitionSize);
            if(this.px !== lastPx || this.py !== lastPy) {
                const lastPartitionKey = `${lastPx},${lastPy}`;
                const newPartitionKey = `${this.px},${this.py}`;
                const lastPartition = Node.partitions[lastPartitionKey];
                if(lastPartition) {
                    const index = lastPartition.indexOf(this);
                    if(index !== -1) {
                        lastPartition.splice(index, 1);
                    }
                }
                if(!Node.partitions[newPartitionKey]) {
                    Node.partitions[newPartitionKey] = [];
                }
                Node.partitions[newPartitionKey].push(this);
            }
        }
        update(deltaTime) {
            this.setPosition(this.x + this.vx * deltaTime * 70, this.y + this.vy * deltaTime * 70);
            let totalDistance = 0;
            for(let dx = -1; dx <= 1; dx++) {
                for(let dy = -1; dy <= 1; dy++) {
                    const partitionKey = `${this.px + dx},${this.py + dy}`;
                    const partition = Node.partitions[partitionKey];
                    if(partition) {
                        partition.forEach(other => {
                            totalDistance += this.updateConnection(other, deltaTime);
                        });
                    }
                }
            }
            totalDistance += this.updateConnection({ x: mouseX * resolution, y: mouseY * resolution }, deltaTime, 4);
            ctx.beginPath();
            ctx.arc(this.x/resolution, this.y/resolution, Math.max(1, 3 / resolution), 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255,255,255,${Math.min(totalDistance/2, 0.8)})`;
            ctx.fill();
            ctx.closePath();
        }
        updateConnection(other, deltaTime, multiplier = 1) {
            let totalDistance = 0;
            if(other !== this) {
                const distX = this.x - other.x;
                const distY = this.y - other.y;
                const dist = Math.sqrt(distX * distX + distY * distY) ** 0.5;
                if(dist < connectionDistance) {
                    ctx.beginPath();
                    ctx.moveTo(this.x/resolution, this.y/resolution);
                    ctx.lineTo(other.x/resolution, other.y/resolution);
                    const opacity = (1 - dist / connectionDistance) * multiplier;
                    ctx.strokeStyle = `rgba(255,255,255,${opacity})`;
                    totalDistance += opacity;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                    ctx.closePath();
                }
                if(dist < 5) {
                    this.vx += distX * 0.2 * deltaTime * multiplier;
                    this.vy += distY * 0.2 * deltaTime * multiplier;
                }
                if(Math.sqrt(this.vx * this.vx + this.vy * this.vy) > 1) {
                    this.vx *= 1/(1+deltaTime*0.2);
                    this.vy *= 1/(1+deltaTime*0.2);
                }
            }
            return totalDistance;
        }
    }

    for(let i=0;i<nodeCount;i++) {
        new Node();
    }
    let lastFrameTime = performance.now();
    function update() {
        const now = performance.now();
        const deltaTime = Math.min((now - lastFrameTime) / 1000, 0.1);
        lastFrameTime = now;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        Node.nodes.forEach(node => {
            node.update(deltaTime);
        });
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        ctx2.drawImage(canvas, 0, 0);
        requestAnimationFrame(update);
    }
    update();


    /////////////////////////////////
    //      Portfolio Content      //
    /////////////////////////////////
    const contentCanvas = document.querySelector('#content-canvas');
    const gl = contentCanvas.getContext('webgl2');
    const vertexSource = `#version 300 es
        layout(location = 0) in vec3 position;
        layout(location = 1) in vec2 texcoord;
        uniform mat4 u_viewMatrix;
        out vec2 v_texcoord;
        void main() {
            gl_Position = u_viewMatrix * vec4(position, 1.0);
            v_texcoord = texcoord;
        }
    `;
    const fragmentSource = `#version 300 es
        precision highp float;
        in vec2 v_texcoord;
        out vec4 color;
        uniform float u_pixelation;
        uniform sampler2D u_texture;
        void main() {
            vec2 samplecoord = floor(v_texcoord * u_pixelation) / u_pixelation;
            color = texture(u_texture, samplecoord);
            color = mix(color , vec4(0.1,0.12,0.15,1), v_texcoord.y * 0.4);
        }
    `;
    const vertexShader = new Shader(gl, gl.VERTEX_SHADER, vertexSource);
    const fragmentShader = new Shader(gl, gl.FRAGMENT_SHADER, fragmentSource);
    const program = new Program(gl, vertexShader, fragmentShader);
    program.setActive();
    const uViewMatrix = new Uniform(gl, program, 'u_viewMatrix', 'mat4');
    const uPixelation = new Uniform(gl, program, 'u_pixelation', 'float');
    uPixelation.set(1000000);
    const vertexArray = new VertexArray(gl);
    vertexArray.setActive();
    const positionBuffer = new Buffer(gl, 0, 3, gl.FLOAT);
    positionBuffer.setActive();
    vertexArray.enableBuffer(positionBuffer);
    const texcoordBuffer = new Buffer(gl, 1, 2, gl.FLOAT);
    texcoordBuffer.setActive();
    vertexArray.enableBuffer(texcoordBuffer);
    const uTexture = new Texture2D(gl, program, 0, 'u_texture', null);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    let vertexCount = 0;
    function renderContent() {
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
    }
    function resizeContentCanvas() {
        contentCanvas.width = window.innerWidth;
        contentCanvas.height = window.innerHeight;
        gl.viewport(0, 0, contentCanvas.width, contentCanvas.height);
        uViewMatrix.set(Mat4.perspective(Math.PI / 4, contentCanvas.width / contentCanvas.height, 0.1, 100));
        const vertices = [];
        const texcoords = [];
        vertexCount = 0;
        const pushFace = (x0,y0,z0,x1,y1,z1, tx0,ty0,tx1,ty1) => {
            vertices.push(
                x0, y0, z0,
                x1, y0, z1,
                x1, y1, z1,
                x0, y0, z0,
                x1, y1, z1,
                x0, y1, z0,
            );
            texcoords.push(
                tx0, ty1,
                tx1, ty1,
                tx1, ty0,
                tx0, ty1,
                tx1, ty0,
                tx0, ty0,
            )
            vertexCount += 6;
        }
        let lean = Math.max(0.6, Math.min(contentCanvas.width / contentCanvas.height / 1.2, 1.5));
        pushFace(
            -2 * lean,
            -1.5,
            -5,
            -0.25 * lean, 
            1.5,
            -10 + 2 * lean,
            0, 0, 0.5, 1,
        );
        pushFace(
            0.25 * lean,
            -1.5,
            -10 + 2 * lean,
            2 * lean, 
            1.5,
            -5,
            0.5, 0, 1, 1,
        );
        positionBuffer.setActive();
        positionBuffer.bufferData(new Float32Array(vertices));
        texcoordBuffer.setActive();
        texcoordBuffer.bufferData(new Float32Array(texcoords));
        renderContent();
    }
    window.addEventListener('resize', resizeContentCanvas);

    const contentCanvas2 = document.createElement('canvas');
    const contentCtx2 = contentCanvas2.getContext('2d');
    const width = 2000;
    const height = 1000;
    contentCanvas2.width = width;
    contentCanvas2.height = height;
    contentCtx2.fillStyle = 'rgba(220,226,242,1)';
    contentCtx2.fillRect(0,0, width, height);
    contentCtx2.fillStyle = 'rgba(0,0,0,0.1)';
    contentCtx2.fillRect(0,0, width, 5);
    contentCtx2.fillRect(0,height-5, width, 5);
    contentCtx2.fillRect(0,0, 5, height);
    contentCtx2.fillRect(width-5,0, 5, height);
    contentCtx2.fillRect(width/2,0, 5, height);
    contentCtx2.fillRect(width/2-5,0, 5, height);
    contentCtx2.fillStyle = 'rgba(0,0,0,0.8)';
    contentCtx2.font = '800 70px "Montserrat", sans-serif';
    contentCtx2.textAlign = 'center';
    contentCtx2.fillText('Spookier', width * 1/4, 105);
    contentCtx2.fillText('Past Work', width * 3/4, 105);
    contentCtx2.fillRect(100, 150, width/2 - 200, 5);
    contentCtx2.fillRect(width/2 + 100, 150, width/2 - 200, 5);

    uTexture.setImage(contentCanvas2);

    resizeContentCanvas();

    let pixelation = 1;
    function updateContent() {
        pixelation += (10000 - pixelation) * 0.00001;
        if(pixelation > 10) pixelation += 0.5;
        if(pixelation > 100) pixelation += 2;
        if(pixelation > 200) pixelation += 5;
        if(pixelation > 1000) pixelation = 100000;
        uPixelation.set(pixelation);
        renderContent();
        if(pixelation > 1000) return;
        requestAnimationFrame(updateContent);
    }
    updateContent();
</script>
</body>
</html>
